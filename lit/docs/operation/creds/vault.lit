\title{\aux{The }Vault credential manager}{vault-credential-manager}

\use-plugin{concourse-docs}
\omit-children-from-table-of-contents

Concourse can be configured to pull credentials from a
\link{Vault}{https://vaultproject.io} instance.

To configure this, first configure the URL of your Vault server by setting the
following env on the \reference{web-node}:

\codeblock{bash}{{{
CONCOURSE_VAULT_URL=https://vault.example.com:8200
}}}

You may also need to configure the CA cert for Vault:

\codeblock{bash}{{{
CONCOURSE_VAULT_CA_CERT=path/to/ca.crt
}}}

You'll also need to configure how the \code{web} node authenticates with Vault
- see \reference{authenticating-with-vault} for more details as that step is
quite involved.

\section{
  \title{Credential lookup rules}{vault-credential-lookup-rules}

  When resolving a parameter such as \code{((foo_param))}, Concourse will look
  in the following paths, in order:

  \list{
    \code{/concourse/TEAM_NAME/PIPELINE_NAME/foo_param}
  }{
    \code{/concourse/TEAM_NAME/foo_param}
  }

  Vault credentials are actually key-value, so for \code{((foo))} Concourse will
  default to the field name \code{value}. You can specify the field to grab via
  \code{.} syntax, e.g. \code{((foo.bar))}.

  If the action is being run in the context of a pipeline (e.g. a \code{check}
  or a step in a build of a job), Concourse will first look in the pipeline
  path. If it's not found there, it will look in the team path. This allows
  credentials to be scoped widely if they're common across many pipelines.

  If an action is being run in a one-off build, Concourse will only look in the
  team path.

  The leading \code{/concourse} can be changed by specifying the following:

  \codeblock{bash}{{{
  CONCOURSE_VAULT_PATH_PREFIX=/some-other-prefix
  }}}
}

\section{
  \title{Configuring the secrets engine}

  Concourse is currently limited to looking under a single path, meaning only
  one secrets engine is supported: \code{kv}, version 1. This may change in the
  future - we're still collecting ideas in \link{(RF)RFC
  #5}{https://github.com/concourse/rfcs/issues/5}.

  So, let's configure the \code{kv} secrets engine and mount it at
  \code{/concourse}:

  \codeblock{bash}{{{
  $ vault secrets enable -version=1 -path=concourse kv
  }}}

  Next, you'll want to create a policy to allow Concourse to read from this
  path.

  \codeblock{hcl}{{{
    path "concourse/*" {
      policy = "read"
    }
  }}}

  Save this to \code{concourse-policy.hcl}, and then run:

  \codeblock{bash}{{{
  vault policy write concourse ./concourse-policy.hcl
  }}}

  This configuration will allow Concourse to read all credentials under
  \code{/concourse}. This should match your configured path prefix.
}

\section{
  \title{Authenticating with Vault}

  There are many ways to authenticate with a Vault server. The \code{web-node}
  can be configured with an arbitrary auth backend and arbitrary auth params,
  so just about all of them should be configurable.

  The two most common auth backends for Concourse with Vault are
  \reference{vault-approle-auth}{\code{approle}} and
  \reference{vault-cert-auth}{\code{cert}}.

  \section{
    \title{Using the \code{approle} auth backend}{vault-approle-auth}

    The
    \link{\code{approle}}{https://www.vaultproject.io/docs/auth/approle.html}
    backend allows for an \italic{app} (in this case, Concourse) to
    authenticate with a \italic{role} pre-configured in Vault.

    With this backend, the \reference{web-node} is configured with a
    \code{role_id} corresponding to a pre-configured role, and a
    \code{secret_id} which is used to authenticate and acquire a token.

    The \code{approle} backend must first be configured in Vault. A typical
    configuration may look something like this:

    \codeblock{bash}{{{
    $ vault auth enable approle
    Success! Enabled approle auth method at: approle/
    $ vault write auth/approle/role/concourse policies=concourse token_ttl=1h
    Success! Data written to: auth/approle/role/concourse
    }}}

    \warn{
      If the \code{secret_id} ever expires, the \code{web} node will no longer
      be able to authenticate until it is restarted with a fresh
      \code{secret_id}.

      For this reason, the \code{approle} backend should not be configured with
      \code{secret_id_ttl} or \code{secret_id_num_uses} unless you have
      something periodically regenerating secret IDs and updating your
      \code{web} nodes.
    }

    Now that the backend is configured, we'll need to obtain the \code{role_id}
    and generate a \code{secret_id}:

    \codeblock{bash}{{{
    $ vault read auth/approle/role/concourse/role-id
    Key        Value
    ---        -----
    role_id    5f3420cd-3c66-2eff-8bcc-0e8e258a7d18
    $ vault write -f auth/approle/role/concourse/secret-id
    Key                   Value
    ---                   -----
    secret_id             f7ec2ac8-ad07-026a-3e1c-4c9781423155
    secret_id_accessor    1bd17fc6-dae1-0c82-d325-3b8f9b5654ee
    }}}

    These should then be set on the \reference{web-node} like so:

    \codeblock{bash}{{{
      CONCOURSE_VAULT_AUTH_BACKEND="approle"
      CONCOURSE_VAULT_AUTH_PARAM="role_id:5f3420cd-3c66-2eff-8bcc-0e8e258a7d18,secret_id:f7ec2ac8-ad07-026a-3e1c-4c9781423155"
    }}}

    On start, Concourse will use the specified \code{role_id} and
    \code{secret_id} to acquire a token from Vault. This token will then be
    used for subsequent API requests. Concourse will renew the token every half
    hour (assuming the \code{token_ttl=1h} from above).
  }

  \section{
    \title{Using the \code{cert} auth backend}{vault-cert-auth}

    The \link{\code{cert}}{https://www.vaultproject.io/docs/auth/cert.html}
    auth method allows authentication using SSL/TLS client certificates.

    With this backend, the \reference{web-node} is configured with a client
    cert and a client key. Vault must be configured with TLS, which you should
    be almost certainly be doing anyway.

    The \code{cert} backend must first be configured in Vault. The backend is
    associated to a policy and a CA cert used to verify the client certificate.
    It may also be given the client certificate itself.

    \codeblock{bash}{{{
    $ vault auth enable cert
    Success! Enabled cert auth method at: cert/
    $ vault write auth/cert/certs/concourse policies=concourse certificate=@out/vault-ca.crt ttl=1h
    Success! Data written to: auth/cert/certs/concourse
    }}}

    Once that's all set up, you'll just need to configure the client cert and
    key on the \code{web} node like so:

    \codeblock{bash}{{{
      CONCOURSE_VAULT_AUTH_BACKEND="cert"
      CONCOURSE_VAULT_CLIENT_CERT=vault-certs/concourse.crt
      CONCOURSE_VAULT_CLIENT_KEY=vault-certs/concourse.key
    }}}

    In this case no additional auth params are necessary, as the Vault's TLS
    auth backend will check the certificate against all roles if no name is
    specified.
  }

  \section{
    \title{Configuring token renewal}

    The \code{web} node will log in to Vault and acquire a token on start. From
    there it will renew the token every (lease duration / 2) so that it doesn't
    expire.

    To set a limit on how long the token can be renewed, the following env can be
    set:

    \codeblock{bash}{{{
    CONCOURSE_VAULT_AUTH_BACKEND_MAX_TTL=1h
    }}}

    This will result in a fresh log-in every hour.
  }
}

\section{
  \title{Configuring credential caching}

  By default, credentials are fetched each time they're used. This can add up
  when many pipelines are configured, resulting in a ton of requests to Vault.

  To reduce load on your Vault server you may want to enable caching, by
  setting the following env on the \reference{web-node}:

  \codeblock{bash}{{{
  CONCOURSE_VAULT_CACHE=true
  }}}

  When enabled, credentials are cached for half of their lease duration.

  To set an upper bound and force cache busting after a certain amount of time,
  set the following env:

  \codeblock{bash}{{{
  CONCOURSE_VAULT_MAX_LEASE=1m
  }}}

  With this set, credentials will only be cached for up to 1 minute.
}

\right-side{Examples}{
  \example{Docker Compose, Vault, \code{cert} auth}{
    Configuring Vault with TLS cert-based auth involves a few moving parts. The
    following example is not really meant for production, but hopefully it
    makes everything easier to understand by seeing how all the parts fit
    together.

    First, grab the Docker Compose quick-start:

    \codeblock{bash}{{{
    $ wget https://concourse-ci.org/docker-compose.yml
    }}}

    Next, let's generate all the certificates using
    \link{\code{certstrap}}{https://github.com/square/certstrap} like so:

    \codeblock{bash}{{{
    certstrap init --cn vault-ca
    certstrap request-cert --domain vault --ip 127.0.0.1
    certstrap sign vault --CA vault-ca
    certstrap request-cert --cn concourse
    certstrap sign concourse --CA vault-ca
    mv out vault-certs
    }}}

    Next we'll configure the Vault server to use the certs we made by creating
    \code{vault-config/config.hcl}:

    \codeblock{hcl}{{{
    listener "tcp" {
      address = "0.0.0.0:8200"
      tls_cert_file = "/vault/certs/vault.crt"
      tls_key_file = "/vault/certs/vault.key"
    }

    storage "file" {
      path = "/vault/file"
    }
    }}}

    Next, let's create a \code{docker-compose.override.yml} override that will
    add Vault and configure cert-based auth:

    \codeblock{yaml}{{{
    version: '3'

    services:
      concourse:
        volumes:
        - ./vault-certs:/vault-certs
        environment:
          CONCOURSE_VAULT_URL: https://vault:8200
          CONCOURSE_VAULT_AUTH_BACKEND: cert
          CONCOURSE_VAULT_CA_CERT: /vault-certs/vault-ca.crt
          CONCOURSE_VAULT_CLIENT_CERT: /vault-certs/concourse.crt
          CONCOURSE_VAULT_CLIENT_KEY: /vault-certs/concourse.key

      vault:
        image: vault
        cap_add: [IPC_LOCK]
        ports: ["8200:8200"]
        volumes:
        - ./vault-certs:/vault/certs
        - ./vault-config:/vault/config
        command: server
    }}}

    From here, we just need to spin up the cluster:

    \codeblock{bash}{{{
    $ docker-compose up
    }}}

    And...now everything should start blowing up! Vault is still sealed, so
    \reference{web-node} can't log in.

    Let's initialize Vault:

    \codeblock{bash}{{{
    $ export VAULT_CACERT=$PWD/vault-certs/vault-ca.crt
    $ vault operator init
    }}}

    Make note of the 5 unseal keys and the root token, then run the following:

    \codeblock{bash}{{{
    $ vault operator unseal # paste unseal key 1
    $ vault operator unseal # paste unseal key 2
    $ vault operator unseal # paste unseal key 3
    $ vault login           # paste root token
    }}}

    At this point Vault is unsealed and ready to go, except we haven't
    configured the \code{cert} backend yet.

    First let's create a policy for Concourse, \code{concourse-policy.hcl}:

    \codeblock{hcl}{{{
      path "concourse/*" {
        policy = "read"
      }
    }}}

    Save this to \code{concourse-policy.hcl}, and then run:

    \codeblock{bash}{{{
    $ vault policy write concourse ./concourse-policy.hcl
    Success! Uploaded policy: concourse
    $ vault auth enable cert
    Success! Enabled cert auth method at: cert/
    $ vault write auth/cert/certs/concourse \
        policies=concourse \
        certificate=@vault-certs/vault-ca.crt \
        ttl=1h
    }}}

    At this point the \code{web} node should be able to log in successfully.
  }
}
